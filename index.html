<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Easy Image Text — Filters, Multi-Page PDF, Camera & OCR</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding:18px; background:#f6f8fb; color:#111; }
    .container { max-width:980px; margin:auto; background:white; padding:16px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    h1 { margin:4px 0 12px; font-size:20px }
    .controls > * { margin-right:8px; margin-bottom:8px; }
    #canvasGrid { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .canvasItem { border:1px solid #e6e6e6; padding:6px; border-radius:6px; background:#fff; min-width:180px; }
    .canvasItem canvas { max-width:100%; height:auto; display:block; background:#fafafa; }
    textarea { width:100%; height:150px; margin-top:12px; padding:8px; font-family:monospace; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button { padding:8px 10px; border-radius:6px; border:1px solid #ddd; background:#fff; cursor:pointer; }
    button.primary { background:#0b74ff; color:white; border-color:#0b74ff; }
    .small { padding:6px 8px; font-size:13px; }
    label { font-size:13px; color:#444; }
    #progressBar { height:8px; background:#eee; border-radius:6px; overflow:hidden; margin-top:8px; }
    #progressBar > i { display:block; height:100%; background:#0b74ff; width:0%; transition:width .2s ease; }
    .muted { color:#666; font-size:13px; }
    .thumb-actions { margin-top:6px; display:flex; gap:6px; align-items:center; justify-content:center; }
    input[type="range"] { width:160px; }
    /* camera modal */
    #cameraModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:9999; }
    #cameraModal .box { background:#fff; padding:10px; border-radius:8px; max-width:420px; width:95%; text-align:center; }
    video { width:100%; border-radius:6px; background:#000; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Easy Image Text — Filters, Multi-Page PDF, Camera & OCR</h1>

    <div class="row controls">
      <input id="fileInput" type="file" accept="image/*,application/pdf" multiple />
      <select id="langSelect">
        <option value="eng">English (eng)</option>
        <option value="hin">Hindi (hin)</option>
        <option value="eng+hin">English + Hindi</option>
      </select>
      <label class="muted">BW threshold: <span id="thVal">128</span></label>
      <input id="thSlider" type="range" min="0" max="255" value="128" />
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="btnOriginal" class="small">Original</button>
      <button id="btnNoShadow" class="small">No Shadow</button>
      <button id="btnLighten" class="small">Lighten</button>
      <button id="btnMagic" class="small">Magic Color</button>
      <button id="btnGray" class="small">Grayscale</button>
      <button id="btnBW" class="small">Black & White</button>
      <button id="btnEco" class="small">Eco</button>
      <button id="autoCrop" class="small">Auto-Crop (edges)</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="exportPdfMulti" class="primary small">Export Multi-Page PDF</button>
      <button id="runOCR" class="small">Recognize Text (OCR)</button>
      <button id="openCamera" class="small">Open Camera</button>
      <button id="clearAll" class="small">Clear All</button>
      <label class="muted" id="hint">Tip: On mobile use file input camera. Multiple images create multi-page PDF.</label>
    </div>

    <div id="progressBar"><i id="progressFill"></i></div>
    <div class="muted" id="statusText" style="margin-top:6px">Status: idle</div>

    <div id="canvasGrid"></div>

    <textarea id="resultText" placeholder="Recognized text will appear here..."></textarea>
  </div>

  <!-- Camera modal -->
  <div id="cameraModal" aria-hidden="true">
    <div class="box">
      <video id="cameraVideo" autoplay playsinline></video>
      <div style="margin-top:8px;">
        <button id="cameraCapture" class="small">Capture</button>
        <button id="cameraClose" class="small" style="margin-left:6px">Close</button>
      </div>
    </div>
  </div>

  <!-- CDNs -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <script>
  (function(){
    // Elements
    const fileInput = document.getElementById('fileInput');
    const canvasGrid = document.getElementById('canvasGrid');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const resultText = document.getElementById('resultText');
    const langSelect = document.getElementById('langSelect');
    const thSlider = document.getElementById('thSlider');
    const thVal = document.getElementById('thVal');

    const openCameraBtn = document.getElementById('openCamera');
    const cameraModal = document.getElementById('cameraModal');
    const cameraVideo = document.getElementById('cameraVideo');
    const cameraCapture = document.getElementById('cameraCapture');
    const cameraClose = document.getElementById('cameraClose');

    let items = []; // { file, img, canvas, ctx, filter, wrap }
    let worker = null;
    let cameraStream = null;

    // pdf.js worker path
    if (window.pdfjsLib) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    function setStatus(s){ statusText.textContent = 'Status: ' + s; }

    thSlider.addEventListener('input', ()=>{ thVal.textContent = thSlider.value; });

    // create canvas item
    function createCanvasItem(img, file){
      const wrap = document.createElement('div'); wrap.className='canvasItem';
      const c = document.createElement('canvas'); const ctx = c.getContext('2d');
      wrap.appendChild(c);
      const actions = document.createElement('div'); actions.className='thumb-actions';
      const btnOrig = makeBtn('Original', ()=>{ item.filter='original'; drawItem(item); });
      const btnBW = makeBtn('BW', ()=>{ item.filter='bw'; drawItem(item); });
      const btnCrop = makeBtn('Crop', ()=>autoCropItem(item));
      const btnDel = makeBtn('Delete', ()=>{ removeItem(item); });
      actions.appendChild(btnOrig); actions.appendChild(btnBW); actions.appendChild(btnCrop); actions.appendChild(btnDel);
      wrap.appendChild(actions);

      const item = { file, img, canvas: c, ctx, filter: 'original', wrap };
      items.push(item);
      canvasGrid.appendChild(wrap);
      drawItem(item);
      return item;
    }

    function makeBtn(text, cb){ const b=document.createElement('button'); b.className='small'; b.textContent=text; b.onclick=cb; return b; }

    function drawItem(item, scaleMaxWidth=1200){
      const img = item.img; const canvas = item.canvas; const ctx = item.ctx;
      let w = img.width, h = img.height;
      if (w > scaleMaxWidth) { h = Math.round(h * (scaleMaxWidth / w)); w = scaleMaxWidth; }
      canvas.width = w; canvas.height = h;
      ctx.save();
      switch(item.filter){
        case 'original': ctx.filter='none'; ctx.drawImage(img,0,0,w,h); break;
        case 'no-shadow': ctx.filter='brightness(1.25) contrast(1.2)'; ctx.drawImage(img,0,0,w,h); break;
        case 'lighten': ctx.filter='brightness(1.2) contrast(1.15)'; ctx.drawImage(img,0,0,w,h); break;
        case 'magic': ctx.filter='saturate(1.4) contrast(1.1) brightness(1.05)'; ctx.drawImage(img,0,0,w,h); break;
        case 'grayscale': ctx.filter='grayscale(1)'; ctx.drawImage(img,0,0,w,h); break;
        case 'eco': ctx.filter='grayscale(1) contrast(0.9) brightness(0.95)'; ctx.drawImage(img,0,0,w,h); break;
        case 'bw': ctx.filter='none'; ctx.drawImage(img,0,0,w,h); binarize(ctx,w,h,parseInt(thSlider.value,10)); break;
        default: ctx.filter='none'; ctx.drawImage(img,0,0,w,h);
      }
      ctx.restore();
    }

    function applyFilterToAll(filterName){ items.forEach(it=>{ it.filter=filterName; drawItem(it); }); }
    function removeItem(item){ const idx = items.indexOf(item); if(idx>=0){ items.splice(idx,1); item.wrap.remove(); } }

    function binarize(ctx,w,h,threshold=128){
      try{
        const imgd = ctx.getImageData(0,0,w,h); const d = imgd.data;
        for(let i=0;i<d.length;i+=4){ const r=d[i], g=d[i+1], b=d[i+2]; const lum = 0.299*r + 0.587*g + 0.114*b; const v = lum >= threshold ? 255 : 0; d[i]=d[i+1]=d[i+2]=v; }
        ctx.putImageData(imgd,0,0);
      } catch(e){ console.warn('binarize fail', e); }
    }

    function autoCropItem(item){
      const c = item.canvas; const ctx = item.ctx; const w = c.width, h = c.height;
      try{
        const imgd = ctx.getImageData(0,0,w,h); const d = imgd.data;
        let minX=w, minY=h, maxX=0, maxY=0;
        const thresh = 230;
        for(let y=0;y<h;y+=2){
          for(let x=0;x<w;x+=2){
            const i = (y*w + x)*4;
            const r=d[i], g=d[i+1], b=d[i+2];
            const lum = 0.299*r + 0.587*g + 0.114*b;
            if(lum < thresh){ if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
          }
        }
        if(maxX<=minX || maxY<=minY){ alert('Auto-crop failed: no content detected'); return; }
        const padding = 8; minX = Math.max(0, minX - padding); minY = Math.max(0, minY - padding);
        maxX = Math.min(w, maxX + padding); maxY = Math.min(h, maxY + padding);
        const nw = maxX - minX, nh = maxY - minY;
        const tmp = document.createElement('canvas'); tmp.width=nw; tmp.height=nh;
        const tctx = tmp.getContext('2d'); tctx.drawImage(c, minX, minY, nw, nh, 0, 0, nw, nh);
        // replace
        item.canvas.width = nw; item.canvas.height = nh; item.ctx.drawImage(tmp,0,0);
        const newImg = new Image(); newImg.onload = ()=>{ item.img = newImg; drawItem(item); }; newImg.src = item.canvas.toDataURL('image/jpeg',0.9);
      } catch(e){ console.warn('autocrop error', e); alert('Auto-crop error'); }
    }

    // file input (images & pdfs)
    fileInput.addEventListener('change', async (ev)=>{
      const files = Array.from(ev.target.files || []);
      if(files.length===0) return;
      setStatus('Loading ' + files.length + ' file(s)...');
      for(const f of files){
        if(f.type === 'application/pdf'){
          try{
            const arr = await f.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({data:arr}).promise;
            const n = pdf.numPages;
            for(let p=1;p<=n;p++){
              const page = await pdf.getPage(p);
              const vp = page.getViewport({ scale: 1.5 });
              const tmp = document.createElement('canvas'); tmp.width = Math.floor(vp.width); tmp.height = Math.floor(vp.height);
              await page.render({ canvasContext: tmp.getContext('2d'), viewport: vp }).promise;
              const img = new Image(); img.src = tmp.toDataURL('image/jpeg',0.9); await new Promise(res=>{ img.onload = res; });
              createCanvasItem(img, f);
            }
          } catch(err){ console.error('pdf load err',err); alert('PDF load error: '+(err.message||err)); }
        } else {
          const url = URL.createObjectURL(f); const img = new Image();
          img.onload = function(){ createCanvasItem(img, f); URL.revokeObjectURL(url); };
          img.src = url;
        }
      }
      setStatus('Files loaded');
    });

    // filter buttons apply to all items
    document.getElementById('btnOriginal').onclick = ()=>applyFilterToAll('original');
    document.getElementById('btnNoShadow').onclick = ()=>applyFilterToAll('no-shadow');
    document.getElementById('btnLighten').onclick = ()=>applyFilterToAll('lighten');
    document.getElementById('btnMagic').onclick = ()=>applyFilterToAll('magic');
    document.getElementById('btnGray').onclick = ()=>applyFilterToAll('grayscale');
    document.getElementById('btnBW').onclick = ()=>applyFilterToAll('bw');
    document.getElementById('btnEco').onclick = ()=>applyFilterToAll('eco');
    document.getElementById('autoCrop').onclick = ()=>items.forEach(it=>autoCropItem(it));
    document.getElementById('clearAll').onclick = ()=>{ items=[]; canvasGrid.innerHTML=''; resultText.value=''; setStatus('Cleared'); progressFill.style.width='0%'; };

    // Export multi-page PDF
    document.getElementById('exportPdfMulti').onclick = ()=>{
      if(items.length===0){ alert('Pehle images add karo'); return; }
      setStatus('Creating PDF...');
      try{
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit:'pt' });
        items.forEach((it, idx)=>{
          const c = it.canvas; const imgData = c.toDataURL('image/jpeg', 0.92);
          const wPt = c.width * 0.75, hPt = c.height * 0.75;
          if(idx===0){ pdf.deletePage(1); pdf.addPage([wPt,hPt]); pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt); }
          else { pdf.addPage([wPt,hPt]); pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt); }
        });
        pdf.save('scan-multipage.pdf'); setStatus('PDF ready');
      } catch(err){ console.error(err); setStatus('PDF error'); alert('PDF export error: '+(err.message||err)); }
    };

    // Tesseract worker init (langPath -> /tessdata for Netlify)
    async function ensureWorker(langVal){
      if(worker) return worker;
      setStatus('Initializing OCR worker...');
      worker = window.Tesseract.createWorker({
        langPath: '/tessdata', // Netlify: put traineddata in public/tessdata
        logger(m){
          if(m.status === 'recognizing text' && typeof m.progress === 'number'){
            progressFill.style.width = Math.round(m.progress*100) + '%';
            setStatus('OCR: recognizing text ' + Math.round(m.progress*100) + '%');
          } else if(m.status){
            setStatus('OCR: ' + m.status);
          }
        }
      });
      await worker.load();
      try { await worker.loadLanguage(langVal); await worker.initialize(langVal); }
      catch(err){ console.warn('lang init failed', err); await worker.loadLanguage('eng'); await worker.initialize('eng'); }
      setStatus('OCR worker ready'); return worker;
    }

    // OCR all canvases sequentially
    document.getElementById('runOCR').onclick = async ()=>{
      if(items.length===0){ alert('Pehle images add karo'); return; }
      const langVal = langSelect.value || 'eng';
      try{
        const w = await ensureWorker(langVal);
        setStatus('Starting OCR on ' + items.length + ' page(s)...');
        let final = '';
        for(let i=0;i<items.length;i++){
          setStatus('Recognizing page ' + (i+1) + ' / ' + items.length);
          const it = items[i];
          drawItem(it);
          const { data } = await w.recognize(it.canvas);
          final += '\n\n--- Page ' + (i+1) + ' ---\n\n' + (data.text || '');
          progressFill.style.width = Math.round(((i+1)/items.length)*100) + '%';
        }
        resultText.value = final.trim();
        setStatus('OCR complete'); progressFill.style.width='100%';
      } catch(err){ console.error(err); setStatus('OCR error'); alert('OCR error: '+(err.message||err)); }
    };

    // Camera integration (open, capture, close)
    openCameraBtn.addEventListener('click', async ()=>{
      try{
        cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        cameraVideo.srcObject = cameraStream; cameraModal.style.display='flex'; cameraModal.setAttribute('aria-hidden','false');
      } catch(err){ alert('Camera access denied/unavailable: '+(err.message||err)); }
    });
    cameraClose.addEventListener('click', ()=>{ stopCamera(); });
    cameraCapture.addEventListener('click', ()=>{
      if(!cameraVideo.videoWidth) return alert('Camera not ready');
      const tmp = document.createElement('canvas'); tmp.width = cameraVideo.videoWidth; tmp.height = cameraVideo.videoHeight;
      const tctx = tmp.getContext('2d'); tctx.drawImage(cameraVideo,0,0,tmp.width,tmp.height);
      const img = new Image(); img.onload = ()=>{ createCanvasItem(img, new File([], 'camera.jpg', { type:'image/jpeg' })); };
      img.src = tmp.toDataURL('image/jpeg', 0.95);
      stopCamera();
    });

    function stopCamera(){ if(cameraStream){ cameraStream.getTracks().forEach(t=>t.stop()); cameraStream=null; } cameraVideo.srcObject=null; cameraModal.style.display='none'; cameraModal.setAttribute('aria-hidden','true'); }

    // safe cleanup before unload
    window.addEventListener('beforeunload', ()=>{ if(worker) worker.terminate && worker.terminate(); if(cameraStream) stopCamera(); });

    // expose createCanvasItem globally for future use (optional)
    window.createCanvasItem = createCanvasItem;

  })();
  </script>
</body>
</html>
