<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Easy OCR — Demo</title>

  <!-- Tailwind Play CDN (fast for prototypes) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small custom tweaks */
    .glass { background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); }
    textarea { resize: vertical; }
    /* ensure debug pre wraps nicely */
    pre.debug { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 py-10">
  <main class="max-w-4xl mx-auto px-4">
    <div class="glass rounded-2xl shadow-lg p-6">
      <header class="mb-4">
        <h1 class="text-2xl font-semibold text-slate-800">Easy Image Text — Demo</h1>
        <p class="text-sm text-slate-500 mt-1">Upload an image, choose language, and extract text instantly — now with PDF download and modern UI.</p>
      </header>

      <!-- Controls -->
      <section class="grid grid-cols-1 md:grid-cols-3 gap-3 items-center">
        <label class="flex items-center gap-3 col-span-1 md:col-span-2">
          <input id="imageInput" type="file" accept="image/*" class="block w-full text-sm text-slate-600 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:bg-slate-100 file:cursor-pointer"/>
        </label>

        <div class="flex gap-2 items-center">
          <select id="lang" class="px-3 py-2 rounded-md border border-slate-200 bg-white text-sm">
            <option value="eng">English (eng)</option>
            <option value="hin">Hindi (hin)</option>
          </select>
          <button id="recognizeBtn" class="inline-flex items-center gap-2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm shadow hover:bg-blue-700 disabled:opacity-60" disabled>
            <svg id="spinner" class="w-4 h-4 animate-spin hidden" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="white" stroke-width="3" stroke-linecap="round" fill="none" stroke-dasharray="60"></circle></svg>
            Recognize Text
          </button>
        </div>
      </section>

      <!-- Preview + result -->
      <section class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div class="border border-slate-100 rounded-lg p-3 bg-white">
          <h3 class="text-sm font-medium text-slate-700 mb-2">Preview</h3>
          <img id="preview" alt="preview image" class="w-full max-h-72 object-contain rounded-md hidden border"/>
          <div id="noPreview" class="text-sm text-slate-400">No image selected</div>
        </div>

        <div class="bg-white border border-slate-100 rounded-lg p-3 flex flex-col">
          <div class="flex items-start justify-between">
            <h3 class="text-sm font-medium text-slate-700">Recognized text</h3>
            <div class="flex gap-2">
              <button id="copyBtn" class="px-3 py-1 rounded-md border border-slate-200 text-sm hover:bg-slate-50">Copy</button>
              <button id="downloadTxt" class="px-3 py-1 rounded-md bg-green-600 text-white text-sm hover:bg-green-700">Download .txt</button>
              <button id="downloadPdf" class="px-3 py-1 rounded-md bg-emerald-700 text-white text-sm hover:bg-emerald-800">Download .pdf</button>
            </div>
          </div>

          <textarea id="result" placeholder="Recognized text will appear here..." class="mt-3 h-56 p-3 border border-slate-100 rounded-md text-sm font-mono text-slate-700"></textarea>
        </div>
      </section>

      <!-- helper + debug -->
      <section class="mt-4 text-sm text-slate-500">
        <p>Tip: Use clear, high-contrast photos for best results. Hindi may take longer to load.</p>
      </section>

      <section class="mt-6">
        <div class="bg-white border border-slate-100 rounded-lg p-4">
          <h4 class="text-sm font-medium text-slate-700 mb-2">Debug</h4>
          <div class="flex gap-4 items-center text-sm">
            <div id="progress" class="text-slate-600"></div>
            <div id="errors" class="text-red-600"></div>
          </div>
          <pre id="debug" class="debug mt-3 text-xs bg-slate-900 text-white p-3 rounded-lg max-h-44 overflow-auto"></pre>
        </div>
      </section>
    </div>
  </main>

  <!-- Libraries: Tesseract + jsPDF -->
  <script>
    // loader to try multiple CDNs for Tesseract
    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=src; s.async=true;
        s.onload=()=>res(src);
        s.onerror=()=>rej(src);
        document.head.appendChild(s);
      });
    }
    (async function(){
      const dbg = el('debug'), errEl = el('errors');
      log("Loading Tesseract...");
      try {
        await loadScript('https://unpkg.com/tesseract.js@2.1.4/dist/tesseract.min.js');
        log("Tesseract loaded (unpkg).");
      } catch(e){
        log("unpkg failed, trying jsdelivr...");
        try { await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@2.1.4/dist/tesseract.min.js'); log("Tesseract loaded (jsdelivr)."); }
        catch(e2){ errEl.textContent = "Failed to load Tesseract library (CDN blocked)"; log("Both Tesseract CDNs failed."); return; }
      }

      // load jsPDF (for PDF export)
      try {
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
        log("jsPDF loaded.");
      } catch(e){
        log("jsPDF CDN failed.", e);
      }

      initUI();
    })();

    // helper
    function el(id){ return document.getElementById(id); }
    function log(msg){ const d=el('debug'); d.textContent += msg + "\n"; console.log(msg); }
    function showErr(msg){ el('errors').textContent = msg; log("ERROR: " + msg); }

    function initUI(){
      const input = el('imageInput'), preview = el('preview'), noPreview = el('noPreview');
      const btn = el('recognizeBtn'), result = el('result'), progressEl = el('progress'), langSel = el('lang');
      const copyBtn = el('copyBtn'), downloadTxt = el('downloadTxt'), downloadPdf = el('downloadPdf');
      const spinner = el('spinner');

      let imgUrl = '';

      input.addEventListener('change', (e)=>{
        const f = e.target.files[0];
        if(!f) return;
        imgUrl = URL.createObjectURL(f);
        preview.src = imgUrl;
        preview.classList.remove('hidden');
        noPreview.style.display = 'none';
        result.value = '';
        btn.disabled = false;
        progressEl.textContent = '';
      });

      btn.addEventListener('click', async ()=>{
        if(!imgUrl) return;
        btn.disabled = true;
        spinner.classList.remove('hidden');
        progressEl.textContent = 'Initializing...';
        el('errors').textContent = '';
        try{
          // use worker pattern
          const worker = Tesseract.createWorker({
            logger: m => {
              const pct = m.progress ? Math.round(m.progress*100) : '';
              progressEl.textContent = `${m.status}${pct? ' ('+pct+'%)':''}`;
              log(`logger: ${m.status} ${pct? '('+pct+'%)':''}`);
            }
          });
          await worker.load();
          const chosen = langSel.value || 'eng';
          await worker.loadLanguage(chosen);
          await worker.initialize(chosen);
          progressEl.textContent = 'Recognizing...';
          const { data } = await worker.recognize(imgUrl);
          result.value = data.text.trim();
          progressEl.textContent = 'Done';
          await worker.terminate();
        } catch(err){
          showErr(err.message || err);
          progressEl.textContent = 'Error';
        } finally {
          btn.disabled = false;
          spinner.classList.add('hidden');
        }
      });

      copyBtn.addEventListener('click', async ()=>{
        try{
          await navigator.clipboard.writeText(result.value || '');
          copyBtn.textContent = 'Copied';
          setTimeout(()=> copyBtn.textContent = 'Copy', 1200);
        } catch(e){
          showErr("Copy failed: " + (e.message||e));
        }
      });

      downloadTxt.addEventListener('click', ()=>{
        const text = result.value || '';
        const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'ocr-result.txt';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      downloadPdf.addEventListener('click', ()=>{
        const text = result.value || '';
        if(!text){ showErr("Nothing to export — run OCR first."); return; }
        try{
          // jsPDF via global (UMD)
          const { jsPDF } = window.jspdf || window.jspdf || {};
          if(!jsPDF){
            showErr("jsPDF not loaded.");
            return;
          }
          const doc = new jsPDF({ unit: 'pt', format: 'a4' });
          const pageWidth = doc.internal.pageSize.getWidth();
          const margin = 40;
          const usableWidth = pageWidth - margin*2;
          doc.setFont('Times', 'Normal');
          doc.setFontSize(12);

          // split large text into lines that fit
          const lines = doc.splitTextToSize(text, usableWidth);
          let cursorY = 60;
          const lineHeight = 14;

          doc.text("OCR result", margin, 40);
          for(let i=0;i<lines.length;i++){
            if(cursorY + lineHeight > doc.internal.pageSize.getHeight() - 40){
              doc.addPage();
              cursorY = 60;
            }
            doc.text(lines[i], margin, cursorY);
            cursorY += lineHeight;
          }
          doc.save('ocr-result.pdf');
        } catch(e){
          showErr("PDF error: " + (e.message||e));
        }
      });

    } // initUI end
  </script>
</body>
</html>
