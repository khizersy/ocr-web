<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Easy Image Text — Filters, Crop, Rotate, Multi-PDF, Camera & OCR</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding:18px; background:#f6f8fb; color:#111; }
    .container { max-width:1100px; margin:auto; background:white; padding:16px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    h1 { margin:4px 0 12px; font-size:20px }
    .controls > * { margin-right:8px; margin-bottom:8px; }
    #canvasGrid { display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .canvasItem { border:1px solid #e6e6e6; padding:8px; border-radius:8px; background:#fff; min-width:220px; width:220px; box-sizing:border-box; position:relative; }
    .canvasItem canvas { width:100%; height:auto; display:block; background:#fafafa; border-radius:4px; }
    textarea { width:100%; height:140px; margin-top:12px; padding:8px; font-family:monospace; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button { padding:8px 10px; border-radius:6px; border:1px solid #ddd; background:#fff; cursor:pointer; }
    button.primary { background:#0b74ff; color:white; border-color:#0b74ff; }
    .small { padding:6px 8px; font-size:13px; }
    label { font-size:13px; color:#444; }
    #progressBar { height:8px; background:#eee; border-radius:6px; overflow:hidden; margin-top:8px; }
    #progressBar > i { display:block; height:100%; background:#0b74ff; width:0%; transition:width .2s ease; }
    .muted { color:#666; font-size:13px; }
    .thumb-actions { margin-top:8px; display:flex; gap:6px; align-items:center; justify-content:center; flex-wrap:wrap; }
    input[type="range"] { width:160px; }
    /* crop overlay */
    .crop-overlay { position:absolute; top:8px; left:8px; right:8px; bottom:48px; pointer-events:none; }
    .sel-rect { position:absolute; border:2px dashed #0b74ff; background: rgba(11,116,255,0.08); pointer-events:none; }
    /* camera modal */
    #cameraModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:9999; }
    #cameraModal .box { background:#fff; padding:10px; border-radius:8px; max-width:420px; width:95%; text-align:center; }
    video { width:100%; border-radius:6px; background:#000; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Easy Image Text — Filters, Crop, Rotate, Multi-Page PDF, Camera & OCR</h1>

    <div class="row controls">
      <input id="fileInput" type="file" accept="image/*,application/pdf" multiple />
      <select id="langSelect">
        <option value="eng">English (eng)</option>
        <option value="hin">Hindi (hin)</option>
        <option value="eng+hin">English + Hindi</option>
      </select>
      <label class="muted">BW threshold: <span id="thVal">128</span></label>
      <input id="thSlider" type="range" min="0" max="255" value="128" />
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="btnOriginal" class="small">Original</button>
      <button id="btnNoShadow" class="small">No Shadow</button>
      <button id="btnLighten" class="small">Lighten</button>
      <button id="btnMagic" class="small">Magic Color</button>
      <button id="btnGray" class="small">Grayscale</button>
      <button id="btnBW" class="small">Black & White</button>
      <button id="btnEco" class="small">Eco</button>
      <button id="autoCrop" class="small">Auto-Crop</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="exportPdfMulti" class="primary small">Export Multi-Page PDF</button>
      <button id="runOCR" class="small">Recognize Text (OCR)</button>
      <button id="openCamera" class="small">Open Camera</button>
      <button id="clearAll" class="small">Clear All</button>
      <label class="muted" id="hint">Tip: On mobile use file input camera. Select 'Black & White' to use threshold.</label>
    </div>

    <div id="progressBar"><i id="progressFill"></i></div>
    <div class="muted" id="statusText" style="margin-top:6px">Status: idle</div>

    <div id="canvasGrid"></div>

    <textarea id="resultText" placeholder="Recognized text will appear here..."></textarea>
  </div>

  <!-- Camera modal -->
  <div id="cameraModal" aria-hidden="true">
    <div class="box">
      <video id="cameraVideo" autoplay playsinline></video>
      <div style="margin-top:8px;">
        <button id="cameraCapture" class="small">Capture</button>
        <button id="cameraClose" class="small" style="margin-left:6px">Close</button>
      </div>
    </div>
  </div>

  <!-- CDNs -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <script>
  (function(){
    // Elements
    const fileInput = document.getElementById('fileInput');
    const canvasGrid = document.getElementById('canvasGrid');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const resultText = document.getElementById('resultText');
    const langSelect = document.getElementById('langSelect');
    const thSlider = document.getElementById('thSlider');
    const thVal = document.getElementById('thVal');

    const openCameraBtn = document.getElementById('openCamera');
    const cameraModal = document.getElementById('cameraModal');
    const cameraVideo = document.getElementById('cameraVideo');
    const cameraCapture = document.getElementById('cameraCapture');
    const cameraClose = document.getElementById('cameraClose');

    let items = []; // { file, img, canvas, ctx, filter, wrap, cropMode, sel }
    let worker = null;
    let cameraStream = null;

    // pdf.js worker path
    if (window.pdfjsLib) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    function setStatus(s){ statusText.textContent = 'Status: ' + s; }

    // threshold slider enable/disable depending on whether any item uses 'bw' filter or global bw applied
    function updateThresholdEnabled(){
      // enable if any item filtered as BW OR if global BW button was clicked recently: we'll check items
      const anyBW = items.some(it=>it.filter==='bw');
      thSlider.disabled = !anyBW;
      thVal.style.opacity = anyBW ? '1' : '0.5';
    }

    thSlider.addEventListener('input', ()=>{ thVal.textContent = thSlider.value; items.forEach(it=>{ if(it.filter==='bw') drawItem(it); }); });

    // create canvas item
    function createCanvasItem(img, file){
      const wrap = document.createElement('div'); wrap.className='canvasItem';
      // container for overlay
      const overlay = document.createElement('div'); overlay.className='crop-overlay';
      wrap.appendChild(overlay);
      const c = document.createElement('canvas'); const ctx = c.getContext('2d');
      wrap.appendChild(c);
      const actions = document.createElement('div'); actions.className='thumb-actions';
      const btnOrig = makeBtn('Original', ()=>{ item.filter='original'; drawItem(item); updateThresholdEnabled(); });
      const btnBW = makeBtn('BW', ()=>{ item.filter='bw'; drawItem(item); updateThresholdEnabled(); });
      const btnRotate = makeBtn('Rotate', ()=>{ rotateItem(item); });
      const btnCrop = makeBtn('Crop', ()=>{ toggleCropMode(item); });
      const btnDel = makeBtn('Delete', ()=>{ removeItem(item); });
      actions.appendChild(btnOrig); actions.appendChild(btnBW); actions.appendChild(btnRotate); actions.appendChild(btnCrop); actions.appendChild(btnDel);
      wrap.appendChild(actions);

      const item = { file, img, canvas: c, ctx, filter: 'original', wrap, overlay, cropMode:false, sel:null, touchStart:null };
      items.push(item);
      canvasGrid.appendChild(wrap);
      drawItem(item);
      updateThresholdEnabled();
      return item;
    }

    function makeBtn(text, cb){ const b=document.createElement('button'); b.className='small'; b.textContent=text; b.onclick=cb; return b; }

    function drawItem(item, scaleMaxWidth=800){
      const img = item.img; const canvas = item.canvas; const ctx = item.ctx;
      let w = img.width, h = img.height;
      if (w > scaleMaxWidth) { h = Math.round(h * (scaleMaxWidth / w)); w = scaleMaxWidth; }
      canvas.width = w; canvas.height = h;
      // draw full-size then apply filter processing
      ctx.save();
      switch(item.filter){
        case 'original': ctx.filter='none'; ctx.drawImage(img,0,0,w,h); break;
        case 'no-shadow': ctx.filter='brightness(1.25) contrast(1.2)'; ctx.drawImage(img,0,0,w,h); break;
        case 'lighten': ctx.filter='brightness(1.2) contrast(1.15)'; ctx.drawImage(img,0,0,w,h); break;
        case 'magic': ctx.filter='saturate(1.4) contrast(1.1) brightness(1.05)'; ctx.drawImage(img,0,0,w,h); break;
        case 'grayscale': ctx.filter='grayscale(1)'; ctx.drawImage(img,0,0,w,h); break;
        case 'eco': ctx.filter='grayscale(1) contrast(0.9) brightness(0.95)'; ctx.drawImage(img,0,0,w,h); break;
        case 'bw':
          ctx.filter='none'; ctx.drawImage(img,0,0,w,h);
          binarize(ctx,w,h,parseInt(thSlider.value,10));
          break;
        default: ctx.filter='none'; ctx.drawImage(img,0,0,w,h);
      }
      ctx.restore();
      // if crop mode active, draw selection overlay
      if(item.cropMode && item.sel){
        drawSelectionOverlay(item);
        attachCropEvents(item);
      } else {
        removeCropEvents(item);
        clearOverlay(item);
      }
    }

    function applyFilterToAll(filterName){ items.forEach(it=>{ it.filter=filterName; drawItem(it); }); updateThresholdEnabled(); }
    function removeItem(item){ const idx = items.indexOf(item); if(idx>=0){ items.splice(idx,1); item.wrap.remove(); updateThresholdEnabled(); } }

    function binarize(ctx,w,h,threshold=128){
      try{
        const imgd = ctx.getImageData(0,0,w,h); const d = imgd.data;
        for(let i=0;i<d.length;i+=4){
          const r=d[i], g=d[i+1], b=d[i+2];
          const lum = 0.299*r + 0.587*g + 0.114*b;
          const v = lum >= threshold ? 255 : 0;
          d[i]=d[i+1]=d[i+2]=v;
        }
        ctx.putImageData(imgd,0,0);
      } catch(e){ console.warn('binarize fail', e); }
    }

    function autoCropItem(item){
      const c = item.canvas; const ctx = item.ctx; const w = c.width, h = c.height;
      try{
        const imgd = ctx.getImageData(0,0,w,h); const d = imgd.data;
        let minX=w, minY=h, maxX=0, maxY=0;
        const thresh = 230;
        for(let y=0;y<h;y+=2){
          for(let x=0;x<w;x+=2){
            const i = (y*w + x)*4;
            const r=d[i], g=d[i+1], b=d[i+2];
            const lum = 0.299*r + 0.587*g + 0.114*b;
            if(lum < thresh){ if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
          }
        }
        if(maxX<=minX || maxY<=minY){ alert('Auto-crop failed: no content detected'); return; }
        const padding = 8; minX = Math.max(0, minX - padding); minY = Math.max(0, minY - padding);
        maxX = Math.min(w, maxX + padding); maxY = Math.min(h, maxY + padding);
        const nw = maxX - minX, nh = maxY - minY;
        const tmp = document.createElement('canvas'); tmp.width=nw; tmp.height=nh;
        const tctx = tmp.getContext('2d'); tctx.drawImage(c, minX, minY, nw, nh, 0, 0, nw, nh);
        item.canvas.width = nw; item.canvas.height = nh; item.ctx.drawImage(tmp,0,0);
        const newImg = new Image(); newImg.onload = ()=>{ item.img = newImg; drawItem(item); }; newImg.src = item.canvas.toDataURL('image/jpeg',0.9);
      } catch(e){ console.warn('autocrop error', e); alert('Auto-crop error'); }
    }

    // rotate item 90 degrees clockwise
    function rotateItem(item){
      const c = item.canvas; const ctx = item.ctx;
      const w = c.width, h = c.height;
      const tmp = document.createElement('canvas'); tmp.width = h; tmp.height = w;
      const tctx = tmp.getContext('2d');
      tctx.translate(h/2, w/2); tctx.rotate(90 * Math.PI / 180); tctx.drawImage(c, -w/2, -h/2);
      // replace item canvas content & image
      item.canvas.width = tmp.width; item.canvas.height = tmp.height;
      item.ctx.drawImage(tmp,0,0);
      const newImg = new Image(); newImg.onload = ()=>{ item.img = newImg; drawItem(item); }; newImg.src = item.canvas.toDataURL('image/jpeg',0.95);
    }

    // Crop mode handlers
    function toggleCropMode(item){
      item.cropMode = !item.cropMode;
      if(item.cropMode){
        item.sel = null;
        setStatus('Crop mode ON — drag to select area on the thumbnail. Then click Apply Crop or Cancel Crop.');
        // add apply/cancel buttons to item's actions bar
        const applyBtn = makeBtn('Apply Crop', ()=>{ applyCrop(item); });
        applyBtn.dataset._applyCrop = '1';
        const cancelBtn = makeBtn('Cancel Crop', ()=>{ cancelCrop(item); });
        cancelBtn.dataset._cancelCrop = '1';
        item.wrap.querySelector('.thumb-actions').appendChild(applyBtn);
        item.wrap.querySelector('.thumb-actions').appendChild(cancelBtn);
      } else {
        cancelCrop(item);
      }
      drawItem(item);
    }

    function applyCrop(item){
      if(!item.sel) return alert('Pehle selection karo');
      const s = item.sel; const c = item.canvas; const ctx = item.ctx;
      const tmp = document.createElement('canvas'); tmp.width = s.w; tmp.height = s.h;
      tmp.getContext('2d').drawImage(c, s.x, s.y, s.w, s.h, 0, 0, s.w, s.h);
      item.canvas.width = tmp.width; item.canvas.height = tmp.height;
      item.ctx.drawImage(tmp,0,0);
      const newImg = new Image(); newImg.onload = ()=>{ item.img = newImg; item.cropMode=false; removeCropButtons(item); drawItem(item); }; newImg.src = item.canvas.toDataURL('image/jpeg',0.95);
    }

    function cancelCrop(item){
      item.cropMode = false; item.sel = null; removeCropButtons(item); drawItem(item);
    }

    function removeCropButtons(item){
      const actions = item.wrap.querySelector('.thumb-actions');
      const toRemove = Array.from(actions.querySelectorAll('button')).filter(b=>b.dataset._applyCrop||b.dataset._cancelCrop);
      toRemove.forEach(b=>b.remove());
    }

    function clearOverlay(item){ item.overlay.innerHTML=''; }
    function drawSelectionOverlay(item){
      // render selection rectangle within overlay (scaled to canvas display)
      const overlay = item.overlay; overlay.innerHTML='';
      if(!item.sel) return;
      const rect = document.createElement('div'); rect.className='sel-rect';
      // compute CSS percent position relative to overlay
      const c = item.canvas; const rectCanvas = item.sel;
      const displayW = item.canvas.clientWidth, displayH = item.canvas.clientHeight;
      const cssX = (rectCanvas.x / c.width) * displayW;
      const cssY = (rectCanvas.y / c.height) * displayH;
      const cssW = (rectCanvas.w / c.width) * displayW;
      const cssH = (rectCanvas.h / c.height) * displayH;
      rect.style.left = cssX + 'px'; rect.style.top = cssY + 'px';
      rect.style.width = Math.max(10, cssW) + 'px'; rect.style.height = Math.max(10, cssH) + 'px';
      overlay.appendChild(rect);
    }

    // attach mouse/touch events to canvas for crop selection
    function attachCropEvents(item){
      const c = item.canvas;
      if(item._cropAttached) return;
      item._cropAttached = true;
      let dragging = false, startX=0, startY=0;
      function getPos(e){
        const r = c.getBoundingClientRect();
        let clientX = e.clientX, clientY = e.clientY;
        if(e.touches && e.touches[0]){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        const x = Math.round(((clientX - r.left) / r.width) * c.width);
        const y = Math.round(((clientY - r.top) / r.height) * c.height);
        return { x, y };
      }
      function onDown(e){
        e.preventDefault();
        if(!item.cropMode) return;
        dragging = true;
        const p = getPos(e);
        startX = p.x; startY = p.y;
        item.sel = { x:startX, y:startY, w:0, h:0 };
        drawSelectionOverlay(item);
      }
      function onMove(e){
        if(!dragging || !item.cropMode) return;
        const p = getPos(e);
        const x = Math.min(startX, p.x), y = Math.min(startY, p.y);
        const w = Math.abs(p.x - startX), h = Math.abs(p.y - startY);
        item.sel = { x, y, w, h };
        drawSelectionOverlay(item);
      }
      function onUp(e){
        if(!dragging) return;
        dragging = false;
        if(item.sel && (item.sel.w < 5 || item.sel.h < 5)){ item.sel = null; drawSelectionOverlay(item); }
      }
      c.addEventListener('mousedown', onDown);
      c.addEventListener('touchstart', onDown, {passive:false});
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('mouseup', onUp);
      window.addEventListener('touchend', onUp);
      // store references so we can remove later
      item._cropHandlers = { onDown, onMove, onUp };
    }

    function removeCropEvents(item){
      if(!item._cropAttached) return;
      const c = item.canvas;
      const h = item._cropHandlers || {};
      c.removeEventListener('mousedown', h.onDown);
      c.removeEventListener('touchstart', h.onDown);
      window.removeEventListener('mousemove', h.onMove);
      window.removeEventListener('touchmove', h.onMove);
      window.removeEventListener('mouseup', h.onUp);
      window.removeEventListener('touchend', h.onUp);
      item._cropAttached = false;
      item._cropHandlers = null;
      item.sel = item.sel; // keep selection if any
      clearOverlay(item);
    }

    // file input (images & pdfs)
    fileInput.addEventListener('change', async (ev)=>{
      const files = Array.from(ev.target.files || []);
      if(files.length===0) return;
      setStatus('Loading ' + files.length + ' file(s)...');
      for(const f of files){
        if(f.type === 'application/pdf'){
          try{
            const arr = await f.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({data:arr}).promise;
            const n = pdf.numPages;
            for(let p=1;p<=n;p++){
              const page = await pdf.getPage(p);
              const vp = page.getViewport({ scale: 1.5 });
              const tmp = document.createElement('canvas'); tmp.width = Math.floor(vp.width); tmp.height = Math.floor(vp.height);
              await page.render({ canvasContext: tmp.getContext('2d'), viewport: vp }).promise;
              const img = new Image(); img.src = tmp.toDataURL('image/jpeg',0.9); await new Promise(res=>{ img.onload = res; });
              createCanvasItem(img, f);
            }
          } catch(err){ console.error('pdf load err',err); alert('PDF load error: '+(err.message||err)); }
        } else {
          const url = URL.createObjectURL(f); const img = new Image();
          img.onload = function(){ createCanvasItem(img, f); URL.revokeObjectURL(url); };
          img.src = url;
        }
      }
      setStatus('Files loaded');
    });

    // filter buttons apply to all items
    document.getElementById('btnOriginal').onclick = ()=>applyFilterToAll('original');
    document.getElementById('btnNoShadow').onclick = ()=>applyFilterToAll('no-shadow');
    document.getElementById('btnLighten').onclick = ()=>applyFilterToAll('lighten');
    document.getElementById('btnMagic').onclick = ()=>applyFilterToAll('magic');
    document.getElementById('btnGray').onclick = ()=>applyFilterToAll('grayscale');
    document.getElementById('btnBW').onclick = ()=>applyFilterToAll('bw');
    document.getElementById('btnEco').onclick = ()=>applyFilterToAll('eco');
    document.getElementById('autoCrop').onclick = ()=>items.forEach(it=>autoCropItem(it));
    document.getElementById('clearAll').onclick = ()=>{ items=[]; canvasGrid.innerHTML=''; resultText.value=''; setStatus('Cleared'); progressFill.style.width='0%'; updateThresholdEnabled(); };

    // Export multi-page PDF
    document.getElementById('exportPdfMulti').onclick = ()=>{
      if(items.length===0){ alert('Pehle images add karo'); return; }
      setStatus('Creating PDF...');
      try{
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit:'pt' });
        items.forEach((it, idx)=>{
          const c = it.canvas; const imgData = c.toDataURL('image/jpeg', 0.92);
          const wPt = c.width * 0.75, hPt = c.height * 0.75;
          if(idx===0){ pdf.deletePage(1); pdf.addPage([wPt,hPt]); pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt); }
          else { pdf.addPage([wPt,hPt]); pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt); }
        });
        pdf.save('scan-multipage.pdf'); setStatus('PDF ready');
      } catch(err){ console.error(err); setStatus('PDF error'); alert('PDF export error: '+(err.message||err)); }
    };

    // Tesseract worker init (langPath -> /tessdata for Netlify)
    async function ensureWorker(langVal){
      if(worker) return worker;
      setStatus('Initializing OCR worker...');
      worker = window.Tesseract.createWorker({
        langPath: '/tessdata', // Netlify: put traineddata in public/tessdata
        logger(m){
          if(m.status === 'recognizing text' && typeof m.progress === 'number'){
            progressFill.style.width = Math.round(m.progress*100) + '%';
            setStatus('OCR: recognizing text ' + Math.round(m.progress*100) + '%');
          } else if(m.status){
            setStatus('OCR: ' + m.status);
          }
        }
      });
      await worker.load();
      try { await worker.loadLanguage(langVal); await worker.initialize(langVal); }
      catch(err){ console.warn('lang init failed', err); await worker.loadLanguage('eng'); await worker.initialize('eng'); }
      setStatus('OCR worker ready'); return worker;
    }

    // OCR all canvases sequentially
    document.getElementById('runOCR').onclick = async ()=>{
      if(items.length===0){ alert('Pehle images add karo'); return; }
      const langVal = langSelect.value || 'eng';
      try{
        const w = await ensureWorker(langVal);
        setStatus('Starting OCR on ' + items.length + ' page(s)...');
        let final = '';
        for(let i=0;i<items.length;i++){
          setStatus('Recognizing page ' + (i+1) + ' / ' + items.length);
          const it = items[i];
          drawItem(it);
          const { data } = await w.recognize(it.canvas);
          final += '\n\n--- Page ' + (i+1) + ' ---\n\n' + (data.text || '');
          progressFill.style.width = Math.round(((i+1)/items.length)*100) + '%';
        }
        resultText.value = final.trim();
        setStatus('OCR complete'); progressFill.style.width='100%';
      } catch(err){ console.error(err); setStatus('OCR error'); alert('OCR error: '+(err.message||err)); }
    };

    // Camera integration (open, capture, close)
    openCameraBtn.addEventListener('click', async ()=>{
      try{
        cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        cameraVideo.srcObject = cameraStream; cameraModal.style.display='flex'; cameraModal.setAttribute('aria-hidden','false');
      } catch(err){ alert('Camera access denied/unavailable: '+(err.message||err)); }
    });
    cameraClose.addEventListener('click', ()=>{ stopCamera(); });
    cameraCapture.addEventListener('click', ()=>{
      if(!cameraVideo.videoWidth) return alert('Camera not ready');
      const tmp = document.createElement('canvas'); tmp.width = cameraVideo.videoWidth; tmp.height = cameraVideo.videoHeight;
      const tctx = tmp.getContext('2d'); tctx.drawImage(cameraVideo,0,0,tmp.width,tmp.height);
      const img = new Image(); img.onload = ()=>{ createCanvasItem(img, new File([], 'camera.jpg', { type:'image/jpeg' })); };
      img.src = tmp.toDataURL('image/jpeg', 0.95);
      stopCamera();
    });

    function stopCamera(){ if(cameraStream){ cameraStream.getTracks().forEach(t=>t.stop()); cameraStream=null; } cameraVideo.srcObject=null; cameraModal.style.display='none'; cameraModal.setAttribute('aria-hidden','true'); }

    // safe cleanup before unload
    window.addEventListener('beforeunload', ()=>{ if(worker) worker.terminate && worker.terminate(); if(cameraStream) stopCamera(); });

    // expose createCanvasItem globally for any external code (optional)
    window.createCanvasItem = createCanvasItem;

  })();
  </script>
</body>
</html>
