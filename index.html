<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Easy Image Text — Crop Indicator Fixed</title>
  <style>
    body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f6f8fb; padding:18px}
    .container{max-width:980px;margin:18px auto;background:#fff;padding:16px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    h1{margin:0 0 12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
    input[type=file],select,button,input[type=range]{padding:6px;border-radius:6px;border:1px solid #ddd;background:#fff}
    #canvasGrid{display:flex;flex-wrap:wrap;gap:12px}
    /* thumbnail */
    .canvasItem{width:220px;border:1px solid #e6e6e6;padding:8px;border-radius:8px;background:#fff;position:relative;overflow:visible}
    .canvasItem canvas{width:100%;height:auto;border-radius:6px;display:block;background:#fafafa}
    .thumb-actions{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:8px}
    /* overlay covers whole thumbnail wrap; box sits above shade */
    .overlay{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:20}
    .shade{position:absolute;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);pointer-events:none;z-index:21}
    .crop-box{position:absolute;border:2px solid #0b74ff;background:transparent;z-index:30;pointer-events:auto; touch-action:none;}
    .crop-box .size{position:absolute; top:-22px; right:0; background:rgba(0,0,0,0.6); color:#fff; font-size:11px; padding:3px 6px; border-radius:4px; z-index:31}
    .handle{width:14px;height:14px;background:#0b74ff;border:2px solid #fff;border-radius:2px;position:absolute;box-sizing:border-box;z-index:35;pointer-events:auto}
    .handle.tl{left:-9px;top:-9px;cursor:nwse-resize}
    .handle.tr{right:-9px;top:-9px;cursor:nesw-resize}
    .handle.bl{left:-9px;bottom:-9px;cursor:nesw-resize}
    .handle.br{right:-9px;bottom:-9px;cursor:nwse-resize}
    #progressBar{height:8px;background:#eee;border-radius:6px;overflow:hidden;margin-top:8px}
    #progressBar i{display:block;height:100%;background:#0b74ff;width:0%;transition:width .15s}
    textarea{width:100%;height:160px;margin-top:12px;padding:8px;font-family:monospace}
    .muted{color:#666;font-size:13px}
    @media (max-width:560px){ .canvasItem{width:48%} }
  </style>
</head>
<body>
  <div class="container">
    <h1>Easy Image Text — Crop Indicator Fixed</h1>

    <div class="row">
      <input id="fileInput" type="file" accept="image/*,application/pdf" multiple />
      <select id="langSelect">
        <option value="auto">Auto-detect</option>
        <option value="eng">English</option>
        <option value="hin">Hindi</option>
        <option value="eng+hin">English+Hindi</option>
      </select>
      <span class="muted">Tip: Click Crop on a thumbnail (or upload/capture) — blue box + handles will appear.</span>
    </div>

    <div class="row">
      <button id="btnOriginal">Original</button>
      <button id="btnBW">Black & White</button>
      <button id="autoCrop">Auto-Crop</button>
      <button id="exportPdfMulti">Export PDF</button>
      <button id="recognizeAll">OCR</button>
    </div>

    <div id="progressBar"><i id="progressFill"></i></div>
    <div id="statusText">Status: idle</div>

    <div id="canvasGrid"></div>
    <textarea id="resultText" placeholder="Recognized text will appear here..."></textarea>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  (function(){
    const fileInput = document.getElementById('fileInput');
    const canvasGrid = document.getElementById('canvasGrid');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const resultText = document.getElementById('resultText');
    const langSelect = document.getElementById('langSelect');

    let items = []; // {file,img,canvas,ctx,wrap,overlay,sel,boxEl,btnApply,btnCancel,filter}
    let worker = null;

    function setStatus(s){ statusText.textContent = 'Status: ' + s; }
    function makeBtn(txt, cb){ const b = document.createElement('button'); b.textContent = txt; b.onclick = cb; return b; }

    // Create thumbnail item
    function createCanvasItem(img, file, autoOpenCrop = false){
      const wrap = document.createElement('div'); wrap.className='canvasItem';
      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
      const actions = document.createElement('div'); actions.className='thumb-actions';

      const item = { file, img, canvas, ctx, wrap, overlay: null, sel: null, boxEl:null, btnApply:null, btnCancel:null, filter:'original' };

      // buttons
      const bCrop = makeBtn('Crop', ()=> openCrop(item));
      const bApply = makeBtn('Apply', ()=> applyCrop(item));
      const bCancel = makeBtn('Cancel', ()=> cancelCrop(item));
      const bRotate = makeBtn('Rotate', ()=> rotateItem(item));
      const bDelete = makeBtn('Delete', ()=> deleteItem(item));
      bApply.style.display='none'; bCancel.style.display='none';
      item.btnApply = bApply; item.btnCancel = bCancel;

      actions.append(bCrop, bApply, bCancel, bRotate, bDelete);
      wrap.appendChild(canvas);
      wrap.appendChild(actions);

      // overlay container (cover whole wrap; box and shade will be added here)
      const overlay = document.createElement('div'); overlay.className = 'overlay';
      wrap.appendChild(overlay);
      item.overlay = overlay;

      items.push(item);
      canvasGrid.appendChild(wrap);

      drawItem(item);

      // if requested auto open crop after small delay for layout to stabilize
      if(autoOpenCrop){
        setTimeout(()=>{ openCrop(item); }, 120);
      }
      return item;
    }

    // Draw image on canvas (resizing to max width)
    function drawItem(item, maxW = 800){
      const img = item.img, canvas = item.canvas, ctx = item.ctx;
      let w = img.width, h = img.height;
      if(w > maxW){ h = Math.round(h * (maxW / w)); w = maxW; }
      canvas.width = w; canvas.height = h;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(img, 0, 0, w, h);
      // keep crop box synced if exists
      if(item.boxEl && item.sel) syncBoxToSel(item);
    }

    // Open crop UI for item
    function openCrop(item){
      // show apply/cancel
      item.btnApply.style.display='inline-block'; item.btnCancel.style.display='inline-block';
      // create shade and box only if not present
      removeBox(item);

      const ov = item.overlay;
      ov.innerHTML = ''; // clear
      // shade (full overlay dark)
      const shade = document.createElement('div'); shade.className = 'shade';
      ov.appendChild(shade);

      // create crop box div
      const box = document.createElement('div'); box.className = 'crop-box';
      const sizeTag = document.createElement('div'); sizeTag.className='size'; box.appendChild(sizeTag);
      // handles
      const tl = document.createElement('div'); tl.className='handle tl';
      const tr = document.createElement('div'); tr.className='handle tr';
      const bl = document.createElement('div'); bl.className='handle bl';
      const br = document.createElement('div'); br.className='handle br';
      box.appendChild(tl); box.appendChild(tr); box.appendChild(bl); box.appendChild(br);

      ov.appendChild(box);
      item.boxEl = box;
      // initial selection: use existing sel or center 70%
      if(!item.sel){
        const cw = item.canvas.width, ch = item.canvas.height;
        const bw = Math.round(cw * 0.75), bh = Math.round(ch * 0.75);
        const bx = Math.round((cw - bw)/2), by = Math.round((ch - bh)/2);
        item.sel = { x: bx, y: by, w: bw, h: bh };
      }
      syncBoxToSel(item);
      attachBoxEvents(item);
    }

    // Remove crop UI
    function removeBox(item){
      if(!item.overlay) return;
      item.overlay.innerHTML = '';
      item.boxEl = null;
    }

    // Sync box position (canvas pixels -> CSS inside wrap)
    function syncBoxToSel(item){
      if(!item.boxEl || !item.sel) return;
      const canvasRect = item.canvas.getBoundingClientRect();
      const wrapRect = item.wrap.getBoundingClientRect();
      // mapping canvas pixel -> display px
      const scaleX = canvasRect.width / item.canvas.width;
      const scaleY = canvasRect.height / item.canvas.height;
      const left = Math.round((item.sel.x * scaleX) + (canvasRect.left - wrapRect.left));
      const top = Math.round((item.sel.y * scaleY) + (canvasRect.top - wrapRect.top));
      const w = Math.max(6, Math.round(item.sel.w * scaleX));
      const h = Math.max(6, Math.round(item.sel.h * scaleY));
      item.boxEl.style.left = left + 'px';
      item.boxEl.style.top = top + 'px';
      item.boxEl.style.width = w + 'px';
      item.boxEl.style.height = h + 'px';
      // size label (show canvas-pixel values)
      const sizeTag = item.boxEl.querySelector('.size');
      if(sizeTag) sizeTag.textContent = Math.round(item.sel.w) + ' x ' + Math.round(item.sel.h);
    }

    // Box interaction: move + resize handles (pointer events mapped to canvas pixels)
    function attachBoxEvents(item){
      if(!item.boxEl) return;
      const box = item.boxEl;
      const handles = box.querySelectorAll('.handle');
      let action = null; // 'move','tl','tr','bl','br'
      let start = null;

      function getCanvasPos(e){
        const cr = item.canvas.getBoundingClientRect();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
        const x = Math.round(((clientX - cr.left) / cr.width) * item.canvas.width);
        const y = Math.round(((clientY - cr.top) / cr.height) * item.canvas.height);
        return { clientX, clientY, x, y };
      }

      function down(e){
        e.preventDefault();
        const t = e.target;
        if(t.classList.contains('handle')) {
          if(t.classList.contains('tl')) action = 'tl';
          else if(t.classList.contains('tr')) action = 'tr';
          else if(t.classList.contains('bl')) action = 'bl';
          else if(t.classList.contains('br')) action = 'br';
        } else action = 'move';
        start = { sel: Object.assign({}, item.sel), pos: getCanvasPos(e) };
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up);
        window.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('touchend', up);
      }

      function move(e){
        if(!start) return;
        e.preventDefault();
        const p = getCanvasPos(e);
        const dx = p.x - start.pos.x;
        const dy = p.y - start.pos.y;
        let sel = Object.assign({}, start.sel);

        if(action === 'move'){
          sel.x = start.sel.x + dx;
          sel.y = start.sel.y + dy;
        } else if(action === 'tl'){
          const newX = Math.min(start.sel.x + start.sel.w - 6, p.x);
          const newY = Math.min(start.sel.y + start.sel.h - 6, p.y);
          sel.w = start.sel.x + start.sel.w - newX;
          sel.h = start.sel.y + start.sel.h - newY;
          sel.x = newX;
          sel.y = newY;
        } else if(action === 'tr'){
          const newX = Math.max(start.sel.x + 6, p.x);
          const newY = Math.min(start.sel.y + start.sel.h - 6, p.y);
          sel.w = Math.max(6, newX - start.sel.x);
          sel.h = start.sel.y + start.sel.h - newY;
          sel.y = newY;
        } else if(action === 'bl'){
          const newX = Math.min(start.sel.x + start.sel.w - 6, p.x);
          const newY = Math.max(start.sel.y + 6, p.y);
          sel.w = start.sel.x + start.sel.w - newX;
          sel.h = Math.max(6, newY - start.sel.y);
          sel.x = newX;
        } else if(action === 'br'){
          const newX = Math.max(start.sel.x + 6, p.x);
          const newY = Math.max(start.sel.y + 6, p.y);
          sel.w = Math.max(6, newX - start.sel.x);
          sel.h = Math.max(6, newY - start.sel.y);
        }

        // clamp within canvas
        sel.x = Math.max(0, Math.min(item.canvas.width - sel.w, sel.x));
        sel.y = Math.max(0, Math.min(item.canvas.height - sel.h, sel.y));
        sel.w = Math.max(6, Math.min(item.canvas.width - sel.x, sel.w));
        sel.h = Math.max(6, Math.min(item.canvas.height - sel.y, sel.h));

        item.sel = sel;
        syncBoxToSel(item);
      }

      function up(){
        start = null; action = null;
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', up);
        window.removeEventListener('touchmove', move);
        window.removeEventListener('touchend', up);
      }

      // pointer attach
      box.addEventListener('mousedown', down);
      box.addEventListener('touchstart', down, {passive:false});
      handles.forEach(h => { h.addEventListener('mousedown', down); h.addEventListener('touchstart', down, {passive:false}); });
    }

    // Apply crop (extract selection in canvas pixels)
    function applyCrop(item){
      if(!item.sel) { alert('No selection'); return; }
      const s = item.sel;
      const tmp = document.createElement('canvas'); tmp.width = s.w; tmp.height = s.h;
      tmp.getContext('2d').drawImage(item.canvas, s.x, s.y, s.w, s.h, 0, 0, s.w, s.h);
      item.canvas.width = s.w; item.canvas.height = s.h;
      item.ctx.drawImage(tmp, 0, 0);
      const newImg = new Image(); newImg.onload = ()=>{ item.img = newImg; drawItem(item); };
      newImg.src = item.canvas.toDataURL('image/jpeg', 0.95);
      item.sel = null; removeBox(item);
      item.btnApply.style.display = 'none'; item.btnCancel.style.display = 'none';
    }

    function cancelCrop(item){
      item.sel = null; removeBox(item);
      item.btnApply.style.display = 'none'; item.btnCancel.style.display = 'none';
    }

    function deleteItem(item){
      const i = items.indexOf(item);
      if(i>=0){ items.splice(i,1); item.wrap.remove(); }
    }

    function rotateItem(item){
      const c = item.canvas;
      const tmp = document.createElement('canvas'); tmp.width = c.height; tmp.height = c.width;
      const t = tmp.getContext('2d'); t.translate(tmp.width/2,tmp.height/2); t.rotate(Math.PI/2); t.drawImage(c,-c.width/2,-c.height/2);
      item.canvas.width = tmp.width; item.canvas.height = tmp.height; item.ctx.drawImage(tmp,0,0);
      const ni = new Image(); ni.onload = ()=>{ item.img = ni; drawItem(item); }; ni.src = item.canvas.toDataURL('image/jpeg',0.95);
    }

    // Filters simplified
    document.getElementById('btnOriginal').onclick = ()=> applyFilterAll('original');
    document.getElementById('btnBW').onclick = ()=> applyFilterAll('bw');
    function applyFilterAll(f){ items.forEach(it=>{ it.filter=f; drawItem(it); }); }

    // Auto-crop placeholder (keeps old behavior)
    document.getElementById('autoCrop').onclick = ()=> items.forEach(it=> simpleAutoCrop(it));
    function simpleAutoCrop(item){
      try {
        const c = item.canvas, ctx = item.ctx;
        const w = c.width, h = c.height;
        const d = ctx.getImageData(0,0,w,h).data;
        let minX=w,minY=h,maxX=0,maxY=0;
        for(let y=0;y<h;y+=4){
          for(let x=0;x<w;x+=4){
            const idx=(y*w+x)*4;
            const lum=0.299*d[idx]+0.587*d[idx+1]+0.114*d[idx+2];
            if(lum<240){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
          }
        }
        if(maxX<=minX||maxY<=minY) return alert('Auto-crop: no content detected');
        const pad=6; minX=Math.max(0,minX-pad); minY=Math.max(0,minY-pad); maxX=Math.min(w,maxX+pad); maxY=Math.min(h,maxY+pad);
        const nw=maxX-minX, nh=maxY-minY;
        const tmp=document.createElement('canvas'); tmp.width=nw; tmp.height=nh;
        tmp.getContext('2d').drawImage(c,minX,minY,nw,nh,0,0,nw,nh);
        item.canvas.width=nw; item.canvas.height=nh; item.ctx.drawImage(tmp,0,0);
        item.img=new Image(); item.img.onload=()=>drawItem(item); item.img.src=item.canvas.toDataURL('image/jpeg',0.95);
      } catch(e){ console.warn(e); alert('Auto-crop error'); }
    }

    // PDF export (simple)
    document.getElementById('exportPdfMulti').onclick = ()=> {
      if(items.length===0) return alert('No images');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit:'pt' });
      items.forEach((it, idx) => {
        const c = it.canvas;
        const img = c.toDataURL('image/jpeg',0.92);
        const wPt = c.width * 0.75, hPt = c.height * 0.75;
        if(idx===0){ pdf.deletePage(1); pdf.addPage([wPt,hPt]); pdf.addImage(img,'JPEG',0,0,wPt,hPt); }
        else { pdf.addPage([wPt,hPt]); pdf.addImage(img,'JPEG',0,0,wPt,hPt); }
      });
      pdf.save('scan-multipage.pdf');
    };

    // OCR (auto-detect eng/hin)
    async function ensureWorker(lang){
      if(worker) return worker;
      setStatus('Loading OCR worker...');
      worker = Tesseract.createWorker({ langPath:'/tessdata', logger:m=>{ if(m.progress) progressFill.style.width = Math.round(m.progress*100)+'%'; } });
      await worker.load();
      try { await worker.loadLanguage(lang); await worker.initialize(lang); }
      catch(e){ await worker.loadLanguage('eng'); await worker.initialize('eng'); }
      setStatus('OCR ready');
      return worker;
    }
    async function detectLanguageFromCanvas(c){
      const s = document.createElement('canvas'); const scale = Math.min(1, 600 / c.width);
      s.width = Math.round(c.width * scale); s.height = Math.round(c.height * scale);
      s.getContext('2d').drawImage(c,0,0,s.width,s.height);
      const w = Tesseract.createWorker({ langPath:'/tessdata' });
      await w.load(); try{ await w.loadLanguage('eng+hin'); await w.initialize('eng+hin'); } catch(e){ await w.loadLanguage('eng'); await w.initialize('eng'); }
      const { data } = await w.recognize(s); await w.terminate();
      return ( /[\u0900-\u097F]/.test(data.text) ? 'hin' : 'eng' );
    }

    document.getElementById('recognizeAll').onclick = async ()=>{
      if(items.length===0) return alert('Add images first');
      let lang = langSelect.value || 'auto';
      setStatus('Preparing OCR...');
      if(lang === 'auto'){ setStatus('Auto-detecting language...'); lang = await detectLanguageFromCanvas(items[0].canvas); setStatus('Detected: '+lang); }
      const w = await ensureWorker(lang);
      let full = '';
      for(let i=0;i<items.length;i++){
        setStatus('Recognizing page ' + (i+1));
        const it = items[i];
        drawItem(it);
        const { data } = await w.recognize(it.canvas);
        full += '\n\n--- Page ' + (i+1) + ' ---\n' + (data.text || '');
      }
      resultText.value = full.trim();
      setStatus('OCR complete');
      progressFill.style.width = '100%';
    };

    // File input
    fileInput.addEventListener('change', (ev)=>{
      const files = Array.from(ev.target.files || []);
      if(files.length===0) return;
      setStatus('Loading files...');
      for(const f of files){
        if(f.type && f.type.startsWith('image/')){
          const url = URL.createObjectURL(f);
          const img = new Image();
          img.onload = ()=> { createCanvasItem(img, f, true); URL.revokeObjectURL(url); };
          img.src = url;
        } else {
          // skip PDFs in this simplified version
          console.warn('Skipping non-image file', f.name);
        }
      }
      setStatus('Files loaded');
    });

    // expose for debugging
    window.createCanvasItem = createCanvasItem;
    setStatus('idle');
  })();
  </script>
</body>
</html>
