<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Easy Image Text — Full</title>
  <style>
    body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f6f8fb; padding:18px}
    .container{max-width:1000px;margin:auto;background:#fff;padding:16px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    h1{margin:0 0 12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
    input[type=file]{padding:6px}
    select, button, input[type=range]{padding:6px;border-radius:6px;border:1px solid #ddd;background:#fff}
    #canvasGrid{display:flex;flex-wrap:wrap;gap:12px}
    .canvasItem{width:220px;border:1px solid #e6e6e6;padding:8px;border-radius:8px;background:#fff;position:relative;box-sizing:border-box}
    .canvasItem canvas{width:100%;height:auto;border-radius:4px;display:block;background:#fafafa}
    .thumb-actions{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:8px}
    .sel-rect{position:absolute;border:2px dashed #0b74ff;background:rgba(11,116,255,0.08);pointer-events:none}
    #progressBar{height:8px;background:#eee;border-radius:6px;overflow:hidden;margin-top:8px}
    #progressBar i{display:block;height:100%;background:#0b74ff;width:0%;transition:width .15s}
    textarea{width:100%;height:160px;margin-top:12px;padding:8px;font-family:monospace}
    #cameraModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center;z-index:9999}
    #cameraModal .box{background:#fff;padding:10px;border-radius:8px;max-width:420px;width:95%;text-align:center}
    video{width:100%;border-radius:6px;background:#000}
    .muted{color:#666;font-size:13px}
    @media (max-width:560px){ .canvasItem{width:48%} }
  </style>
</head>
<body>
  <div class="container">
    <h1>Easy Image Text — Full</h1>

    <div class="row">
      <input id="fileInput" type="file" accept="image/*,application/pdf" multiple />
      <select id="langSelect">
        <option value="eng">English (eng)</option>
        <option value="hin">Hindi (hin)</option>
        <option value="eng+hin">English + Hindi</option>
      </select>
      <label class="muted">BW threshold: <span id="thVal">128</span></label>
      <input id="thSlider" type="range" min="0" max="255" value="128" />
    </div>

    <div class="row">
      <button id="btnOriginal" class="small">Original</button>
      <button id="btnNoShadow" class="small">No Shadow</button>
      <button id="btnLighten" class="small">Lighten</button>
      <button id="btnMagic" class="small">Magic Color</button>
      <button id="btnGray" class="small">Grayscale</button>
      <button id="btnBW" class="small">Black & White</button>
      <button id="btnEco" class="small">Eco</button>
      <button id="autoCrop" class="small">Auto-Crop</button>
    </div>

    <div class="row">
      <button id="exportPdfMulti" class="primary small">Export Multi-Page PDF</button>
      <button id="recognizeAll" class="small">Recognize Text (OCR)</button>
      <button id="openCamera" class="small">Open Camera</button>
      <button id="clearAll" class="small">Clear All</button>
      <button id="downloadAll" class="small">Download Images ZIP</button>
      <span class="muted" style="margin-left:8px">Tip: Select Black & White to enable threshold slider.</span>
    </div>

    <div id="progressBar"><i id="progressFill"></i></div>
    <div id="statusText" class="muted" style="margin-top:6px">Status: idle</div>

    <div id="canvasGrid"></div>

    <textarea id="resultText" placeholder="Recognized text will appear here..."></textarea>
  </div>

  <!-- Camera modal -->
  <div id="cameraModal" aria-hidden="true">
    <div class="box">
      <video id="cameraVideo" autoplay playsinline></video>
      <div style="margin-top:8px">
        <button id="cameraCapture" class="small">Capture</button>
        <button id="cameraClose" class="small">Close</button>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <script>
  (function(){
    // elements
    const fileInput = document.getElementById('fileInput');
    const canvasGrid = document.getElementById('canvasGrid');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const resultText = document.getElementById('resultText');
    const langSelect = document.getElementById('langSelect');
    const thSlider = document.getElementById('thSlider');
    const thVal = document.getElementById('thVal');

    const openCameraBtn = document.getElementById('openCamera');
    const cameraModal = document.getElementById('cameraModal');
    const cameraVideo = document.getElementById('cameraVideo');
    const cameraCapture = document.getElementById('cameraCapture');
    const cameraClose = document.getElementById('cameraClose');

    let items = []; // {file,img,canvas,ctx,filter,sel,cropMode,_rect,_cropAttached,_cropHandlers}
    let worker = null;
    let cameraStream = null;

    // pdf.js worker
    if(window.pdfjsLib) window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    // helpers
    function setStatus(s){ statusText.textContent = 'Status: ' + s; }
    function makeBtn(text, cb){ const b=document.createElement('button'); b.className='small'; b.textContent=text; b.onclick=cb; return b; }

    // create item (button closures capture item after object created)
    function createCanvasItem(img, file){
      const wrap = document.createElement('div'); wrap.className='canvasItem';
      const c = document.createElement('canvas'); const ctx = c.getContext('2d');
      const actions = document.createElement('div'); actions.className='thumb-actions';

      const item = { file, img, canvas: c, ctx, wrap, filter: 'original', sel: null, cropMode: false };

      // buttons (use item in closures)
      const btnCrop = makeBtn('Crop', ()=> toggleCropMode(item));
      const btnApply = makeBtn('Apply', ()=> applyCrop(item));
      const btnCancel = makeBtn('Cancel', ()=> cancelCrop(item));
      const btnRotate = makeBtn('Rotate', ()=> rotateItem(item));
      const btnDownload = makeBtn('Download', ()=> downloadImageItem(item));

      btnApply.style.display = 'none';
      btnCancel.style.display = 'none';

      // append
      actions.append(btnCrop, btnApply, btnCancel, btnRotate, btnDownload);
      wrap.appendChild(c);
      wrap.appendChild(actions);

      // attach references
      item.btnApply = btnApply; item.btnCancel = btnCancel; item.actions = actions;

      items.push(item);
      canvasGrid.appendChild(wrap);
      drawItem(item);
      updateThresholdEnabled();
      return item;
    }

    // draw with filter
    function drawItem(item, maxW=800){
      const img = item.img; const c = item.canvas; const ctx = item.ctx;
      let w = img.width, h = img.height;
      if(w > maxW){ h = Math.round(h * (maxW / w)); w = maxW; }
      c.width = w; c.height = h;
      ctx.save();
      switch(item.filter){
        case 'no-shadow': ctx.filter='brightness(1.25) contrast(1.18)'; ctx.drawImage(img,0,0,w,h); break;
        case 'lighten': ctx.filter='brightness(1.2) contrast(1.14)'; ctx.drawImage(img,0,0,w,h); break;
        case 'magic': ctx.filter='saturate(1.4) contrast(1.08) brightness(1.04)'; ctx.drawImage(img,0,0,w,h); break;
        case 'grayscale': ctx.filter='grayscale(1)'; ctx.drawImage(img,0,0,w,h); break;
        case 'eco': ctx.filter='grayscale(1) contrast(0.92) brightness(0.97)'; ctx.drawImage(img,0,0,w,h); break;
        case 'bw': ctx.filter='none'; ctx.drawImage(img,0,0,w,h); binarize(ctx,w,h,parseInt(thSlider.value,10)); break;
        default: ctx.filter='none'; ctx.drawImage(img,0,0,w,h);
      }
      ctx.restore();
      if(item.cropMode) attachCropEvents(item);
      if(item.sel) drawSelectionOverlay(item);
    }

    // binarize for BW
    function binarize(ctx, w, h, threshold=128){
      try {
        const imgd = ctx.getImageData(0,0,w,h), d = imgd.data;
        for(let i=0;i<d.length;i+=4){
          const r=d[i], g=d[i+1], b=d[i+2];
          const lum = 0.299*r + 0.587*g + 0.114*b;
          const v = lum >= threshold ? 255 : 0;
          d[i]=d[i+1]=d[i+2]=v;
        }
        ctx.putImageData(imgd,0,0);
      } catch(e){ console.warn('binarize error', e); }
    }

    // rotate 90deg clockwise
    function rotateItem(item){
      const c = item.canvas;
      const tmp = document.createElement('canvas');
      tmp.width = c.height; tmp.height = c.width;
      const tctx = tmp.getContext('2d');
      tctx.translate(tmp.width/2, tmp.height/2);
      tctx.rotate(90*Math.PI/180);
      tctx.drawImage(c, -c.width/2, -c.height/2);
      item.canvas.width = tmp.width; item.canvas.height = tmp.height;
      item.ctx.drawImage(tmp, 0, 0);
      const newImg = new Image(); newImg.onload = ()=> { item.img = newImg; drawItem(item); };
      newImg.src = item.canvas.toDataURL('image/jpeg', 0.95);
    }

    // Crop mode
    function toggleCropMode(item){
      item.cropMode = !item.cropMode;
      item.btnApply.style.display = item.cropMode ? 'inline-block' : 'none';
      item.btnCancel.style.display = item.cropMode ? 'inline-block' : 'none';
      if(item.cropMode) attachCropEvents(item); else removeCropEvents(item);
    }

    function applyCrop(item){
      if(!item.sel) return alert('No selection');
      const s = item.sel;
      const tmp = document.createElement('canvas');
      tmp.width = s.w; tmp.height = s.h;
      tmp.getContext('2d').drawImage(item.canvas, s.x, s.y, s.w, s.h, 0, 0, s.w, s.h);
      item.canvas.width = s.w; item.canvas.height = s.h;
      item.ctx.drawImage(tmp, 0, 0);
      const newImg = new Image(); newImg.onload = ()=> { item.img = newImg; drawItem(item); };
      newImg.src = item.canvas.toDataURL('image/jpeg', 0.95);
      item.sel = null; item.cropMode = false;
      item.btnApply.style.display = 'none'; item.btnCancel.style.display = 'none';
      clearOverlay(item);
    }

    function cancelCrop(item){
      item.sel = null; item.cropMode = false;
      item.btnApply.style.display = 'none'; item.btnCancel.style.display = 'none';
      clearOverlay(item);
    }

    // overlay draw
    function drawSelectionOverlay(item){
      clearOverlay(item);
      if(!item.sel) return;
      const r = item.canvas.getBoundingClientRect();
      const sx = (item.sel.x / item.canvas.width) * r.width;
      const sy = (item.sel.y / item.canvas.height) * r.height;
      const sw = (item.sel.w / item.canvas.width) * r.width;
      const sh = (item.sel.h / item.canvas.height) * r.height;
      const rect = document.createElement('div');
      rect.className = 'sel-rect';
      rect.style.left = sx + 'px';
      rect.style.top = sy + 'px';
      rect.style.width = Math.max(6, sw) + 'px';
      rect.style.height = Math.max(6, sh) + 'px';
      rect.style.position = 'absolute';
      item._rect = rect;
      item.wrap.appendChild(rect);
    }
    function clearOverlay(item){ if(item._rect){ item._rect.remove(); item._rect = null; } }

    // crop events (map screen to canvas pixels)
    function attachCropEvents(item){
      if(item._cropAttached) return;
      const c = item.canvas;
      let dragging = false, sx = 0, sy = 0;
      function getPos(e){
        const r = c.getBoundingClientRect();
        let cx = (e.touches ? e.touches[0].clientX : e.clientX);
        let cy = (e.touches ? e.touches[0].clientY : e.clientY);
        const x = Math.round(((cx - r.left) / r.width) * c.width);
        const y = Math.round(((cy - r.top) / r.height) * c.height);
        return {x,y};
      }
      function onDown(e){
        if(!item.cropMode) return;
        e.preventDefault();
        dragging = true;
        const p = getPos(e);
        sx = p.x; sy = p.y;
        item.sel = {x: sx, y: sy, w: 0, h: 0};
        drawSelectionOverlay(item);
      }
      function onMove(e){
        if(!dragging) return;
        e.preventDefault();
        const p = getPos(e);
        const x = Math.min(sx, p.x), y = Math.min(sy, p.y);
        const w = Math.abs(p.x - sx), h = Math.abs(p.y - sy);
        item.sel = {x, y, w, h};
        drawSelectionOverlay(item);
      }
      function onUp(e){
        if(!dragging) return;
        dragging = false;
        // ignore micro selections
        if(item.sel && (item.sel.w < 6 || item.sel.h < 6)){ item.sel = null; clearOverlay(item); }
      }
      c.addEventListener('mousedown', onDown);
      c.addEventListener('touchstart', onDown, {passive:false});
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('mouseup', onUp);
      window.addEventListener('touchend', onUp);
      item._cropAttached = true;
      item._cropHandlers = {onDown, onMove, onUp};
    }

    function removeCropEvents(item){
      if(!item._cropAttached) return;
      const h = item._cropHandlers;
      try {
        item.canvas.removeEventListener('mousedown', h.onDown);
        item.canvas.removeEventListener('touchstart', h.onDown);
        window.removeEventListener('mousemove', h.onMove);
        window.removeEventListener('touchmove', h.onMove);
        window.removeEventListener('mouseup', h.onUp);
        window.removeEventListener('touchend', h.onUp);
      } catch(e){}
      item._cropAttached = false;
      item._cropHandlers = null;
    }

    // downloads single image
    function downloadImageItem(item){
      const link = document.createElement('a');
      link.href = item.canvas.toDataURL('image/jpeg', 0.95);
      link.download = (item.file && item.file.name) ? ('processed-' + item.file.name) : 'processed.jpg';
      link.click();
    }

    // multi-image export to PDF
    document.getElementById('exportPdfMulti').addEventListener('click', ()=>{
      if(items.length === 0) return alert('Add images first');
      setStatus('Creating PDF...');
      try {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'pt' });
        items.forEach((it, idx) => {
          const c = it.canvas;
          const imgData = c.toDataURL('image/jpeg', 0.92);
          const wPt = c.width * 0.75, hPt = c.height * 0.75;
          if(idx === 0){
            pdf.deletePage(1);
            pdf.addPage([wPt, hPt]);
            pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt);
          } else {
            pdf.addPage([wPt, hPt]);
            pdf.addImage(imgData, 'JPEG', 0, 0, wPt, hPt);
          }
        });
        pdf.save('scan-multipage.pdf');
        setStatus('PDF ready');
      } catch(err){ console.error(err); alert('PDF export error'); setStatus('PDF error'); }
    });

    // OCR init with langPath -> Netlify friendly
    async function ensureWorker(lang){
      if(worker) return worker;
      setStatus('Initializing OCR worker...');
      worker = window.Tesseract.createWorker({
        langPath: '/tessdata',
        logger: m => {
          if(m.status === 'recognizing text' && typeof m.progress === 'number'){
            progressFill.style.width = Math.round(m.progress * 100) + '%';
            setStatus('OCR: recognizing ' + Math.round(m.progress * 100) + '%');
          } else if(m.status) setStatus('OCR: ' + m.status);
        }
      });
      await worker.load();
      try {
        await worker.loadLanguage(lang);
        await worker.initialize(lang);
      } catch(e){
        console.warn('lang init failed', e);
        await worker.loadLanguage('eng'); await worker.initialize('eng');
      }
      setStatus('OCR worker ready');
      return worker;
    }

    // Recognize all canvases sequentially
    document.getElementById('recognizeAll').addEventListener('click', async ()=>{
      if(items.length === 0) return alert('Add images');
      const lang = langSelect.value || 'eng';
      try {
        const w = await ensureWorker(lang);
        setStatus('Starting OCR on ' + items.length + ' page(s)...');
        let final = '';
        for(let i=0;i<items.length;i++){
          setStatus('Recognizing page ' + (i+1) + ' / ' + items.length);
          const it = items[i];
          drawItem(it);
          const { data } = await w.recognize(it.canvas);
          final += '\n\n--- Page ' + (i+1) + ' ---\n\n' + (data.text || '');
          progressFill.style.width = Math.round(((i+1)/items.length)*100) + '%';
        }
        resultText.value = final.trim();
        setStatus('OCR complete');
        progressFill.style.width = '100%';
      } catch(err){ console.error(err); setStatus('OCR error'); alert('OCR error: ' + (err.message || err)); }
    });

    // file input (images & pdfs)
    fileInput.addEventListener('change', async (ev)=>{
      const files = Array.from(ev.target.files || []);
      if(files.length === 0) return;
      setStatus('Loading ' + files.length + ' file(s)...');
      for(const f of files){
        if(f.type === 'application/pdf'){
          try {
            const arr = await f.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({data:arr}).promise;
            const n = pdf.numPages;
            for(let p=1;p<=n;p++){
              const page = await pdf.getPage(p);
              const vp = page.getViewport({ scale: 1.5 });
              const tmp = document.createElement('canvas');
              tmp.width = Math.floor(vp.width); tmp.height = Math.floor(vp.height);
              await page.render({ canvasContext: tmp.getContext('2d'), viewport: vp }).promise;
              const img = new Image(); img.src = tmp.toDataURL('image/jpeg', 0.9);
              await new Promise(res => img.onload = res);
              createCanvasItem(img, f);
            }
          } catch(e){ console.error('PDF load error', e); alert('PDF load error: ' + (e.message || e)); }
        } else {
          const url = URL.createObjectURL(f);
          const img = new Image();
          img.onload = ()=> { createCanvasItem(img, f); URL.revokeObjectURL(url); };
          img.src = url;
        }
      }
      setStatus('Files loaded');
    });

    // global filter buttons
    document.getElementById('btnOriginal').onclick = ()=> applyFilterToAll('original');
    document.getElementById('btnNoShadow').onclick = ()=> applyFilterToAll('no-shadow');
    document.getElementById('btnLighten').onclick = ()=> applyFilterToAll('lighten');
    document.getElementById('btnMagic').onclick = ()=> applyFilterToAll('magic');
    document.getElementById('btnGray').onclick = ()=> applyFilterToAll('grayscale');
    document.getElementById('btnBW').onclick = ()=> applyFilterToAll('bw');
    document.getElementById('btnEco').onclick = ()=> applyFilterToAll('eco');
    document.getElementById('autoCrop').onclick = ()=> items.forEach(it => autoCropItem(it));
    document.getElementById('clearAll').onclick = ()=> { items = []; canvasGrid.innerHTML=''; resultText.value=''; setStatus('Cleared'); progressFill.style.width='0%'; updateThresholdEnabled(); };
    document.getElementById('downloadAll').onclick = ()=> { if(items.length===0) return alert('No images'); items.forEach(it=>downloadImageItem(it)); };

    function applyFilterToAll(filterName){ items.forEach(it => { it.filter = filterName; drawItem(it); }); updateThresholdEnabled(); }

    function updateThresholdEnabled(){
      const anyBW = items.some(it => it.filter === 'bw');
      thSlider.disabled = !anyBW;
      thVal.style.opacity = anyBW ? '1' : '0.45';
    }
    thSlider.addEventListener('input', ()=>{ thVal.textContent = thSlider.value; items.forEach(it => { if(it.filter === 'bw') drawItem(it); }) });

    // simple auto-crop (bounding box)
    function autoCropItem(item){
      try {
        const c = item.canvas; const ctx = item.ctx;
        const w = c.width, h = c.height;
        const imgd = ctx.getImageData(0,0,w,h); const d = imgd.data;
        let minX=w, minY=h, maxX=0, maxY=0;
        const thresh = 230;
        for(let y=0;y<h;y+=3){
          for(let x=0;x<w;x+=3){
            const i = (y*w + x)*4;
            const lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
            if(lum < thresh){ if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
          }
        }
        if(maxX<=minX || maxY<=minY) return alert('Auto-crop: no content detected');
        const pad = 8; minX = Math.max(0, minX-pad); minY = Math.max(0, minY-pad); maxX = Math.min(w, maxX+pad); maxY = Math.min(h, maxY+pad);
        const nw = maxX - minX, nh = maxY - minY;
        const tmp = document.createElement('canvas'); tmp.width = nw; tmp.height = nh;
        tmp.getContext('2d').drawImage(c, minX, minY, nw, nh, 0, 0, nw, nh);
        item.canvas.width = nw; item.canvas.height = nh; item.ctx.drawImage(tmp,0,0);
        item.img = new Image(); item.img.onload = ()=> drawItem(item); item.img.src = item.canvas.toDataURL('image/jpeg', 0.95);
      } catch(e){ console.warn('autoCrop error', e); alert('Auto-crop error'); }
    }

    // camera capture
    openCameraBtn.addEventListener('click', async ()=>{
      try {
        cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        cameraVideo.srcObject = cameraStream;
        cameraModal.style.display = 'flex'; cameraModal.setAttribute('aria-hidden', 'false');
      } catch(e){ alert('Camera access denied or unavailable: ' + (e.message || e)); }
    });
    cameraClose.addEventListener('click', stopCamera);
    cameraCapture.addEventListener('click', ()=>{
      if(!cameraVideo.videoWidth) return alert('Camera not ready');
      const tmp = document.createElement('canvas'); tmp.width = cameraVideo.videoWidth; tmp.height = cameraVideo.videoHeight;
      tmp.getContext('2d').drawImage(cameraVideo, 0, 0, tmp.width, tmp.height);
      const img = new Image(); img.onload = ()=> createCanvasItem(img, new File([], 'camera.jpg', { type: 'image/jpeg' }));
      img.src = tmp.toDataURL('image/jpeg', 0.95);
      stopCamera();
    });
    function stopCamera(){
      if(cameraStream){ cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
      cameraVideo.srcObject = null; cameraModal.style.display = 'none'; cameraModal.setAttribute('aria-hidden', 'true');
    }

    // expose createCanvasItem globally (for debug)
    window.createCanvasItem = createCanvasItem;

    // ensure worker: only on-demand
    async function ensureWorker(lang){
      return ensureWorkerInternal(lang);
    }
    // small indirection to avoid duplicate declaration issues
    async function ensureWorkerInternal(lang){
      if(worker) return worker;
      worker = window.Tesseract.createWorker({
        langPath: '/tessdata',
        logger: m => { if(m.status === 'recognizing text' && typeof m.progress === 'number'){ progressFill.style.width = Math.round(m.progress*100) + '%'; setStatus('OCR: ' + Math.round(m.progress*100) + '%'); } else if(m.status) setStatus('OCR: ' + m.status); }
      });
      await worker.load();
      try { await worker.loadLanguage(lang); await worker.initialize(lang); }
      catch(e){ console.warn('lang init failed', e); await worker.loadLanguage('eng'); await worker.initialize('eng'); }
      setStatus('OCR worker ready');
      return worker;
    }

    // helper: download single or multiple images (simple)
    function downloadImageItem(item){
      const a = document.createElement('a'); a.href = item.canvas.toDataURL('image/jpeg', 0.95);
      a.download = (item.file && item.file.name) ? ('processed-' + item.file.name) : 'processed.jpg'; a.click();
    }

    // handle drag & drop event (optional)
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      e.preventDefault();
      if(e.dataTransfer && e.dataTransfer.files) {
        fileInput.files = e.dataTransfer.files;
        const ev = new Event('change'); fileInput.dispatchEvent(ev);
      }
    });

    // init simple UI state
    setStatus('idle');

  })();
  </script>
</body>
</html>
